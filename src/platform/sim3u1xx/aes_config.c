//------------------------------------------------------------------------------
// Copyright (c) 2012 by Silicon Laboratories. 
// All rights reserved. This program and the accompanying materials
// are made available under the terms of the Silicon Laboratories End User 
// License Agreement which accompanies this distribution, and is available at
// http://developer.silabs.com/legal/version/v10/License_Agreement_v10.htm
// Original content and implementation provided by Silicon Laboratories.
//------------------------------------------------------------------------------

//==============================================================================
// WARNING:
//
// This file is auto-generated by AppBuilder and should not be modified.
// Any hand modifications will be lost if the project is regenerated.
//==============================================================================
// library
// hal
#include <si32_device.h>
#include <SI32_AES_A_Type.h>
#include <SI32_CLKCTRL_A_Type.h>
// application
//#include "gAES0.h"

//==============================================================================
// 2nd Level Interrupt Handlers
//==============================================================================
extern void aes_error_handler(void);

//==============================================================================
//1st LEVEL  INTERRUPT HANDLERS
//==============================================================================
// Prints the value measured at the end of each convert, and a newline at the
// end of each scan
void AES0_IRQHandler(void)
{
   if ((SI32_AES_A_is_error_interrupt_pending(SI32_AES_0) &
        SI32_AES_A_is_error_interrupt_enabled(SI32_AES_0)))
   {
      aes_error_handler();
   }
}

//==============================================================================
//CONFIGURATION FUNCTIONS
//==============================================================================
void gAES0_enter_off_config(void)
{
   // DISAABLE INTERRUPTS
   SI32_AES_A_disable_operation_complete_interrupt(SI32_AES_0);
   NVIC_ClearPendingIRQ(AES0_IRQn);
   NVIC_DisableIRQ(AES0_IRQn);

   // DISABLE MODULE
   SI32_AES_A_disable_module(SI32_AES_0);

   // DISABLE CLOCK
   SI32_CLKCTRL_A_disable_apb_to_modules_0(SI32_CLKCTRL_0,
                                           SI32_CLKCTRL_A_APBCLKG0_AES0CEN_ENABLED_U32);
}

//------------------------------------------------------------------------------
void gAES0_enter_ecb_config(void)
{
   // ENABLE CLOCK
   SI32_CLKCTRL_A_enable_apb_to_modules_0(SI32_CLKCTRL_0,
                                          SI32_CLKCTRL_A_APBCLKG0_AES0CEN_ENABLED_U32);

   // ENABLE MODULE
   SI32_AES_A_enable_module(SI32_AES_0);

   // SETUP MODULE
   SI32_AES_A_write_xfrsize(SI32_AES_0, 0);
   SI32_AES_A_enable_error_interrupt(SI32_AES_0);
   SI32_AES_A_exit_cipher_block_chaining_mode(SI32_AES_0);
   SI32_AES_A_exit_counter_mode(SI32_AES_0);
   SI32_AES_A_select_xor_path_none(SI32_AES_0);
   SI32_AES_A_exit_bypass_hardware_mode(SI32_AES_0);
   SI32_AES_A_enable_key_capture (SI32_AES_0);
   SI32_AES_A_select_software_mode (SI32_AES_0);

   // ENABLE INTERRUPTS
   NVIC_ClearPendingIRQ(AES0_IRQn);
   NVIC_EnableIRQ(AES0_IRQn);
}

//------------------------------------------------------------------------------
void gAES0_enter_cbc_config(void)
{
   // ENABLE CLOCK
   SI32_CLKCTRL_A_enable_apb_to_modules_0(SI32_CLKCTRL_0,
                                          SI32_CLKCTRL_A_APBCLKG0_AES0CEN_ENABLED_U32);

   // ENABLE MODULE
   SI32_AES_A_enable_module(SI32_AES_0);

   // SETUP MODULE
   SI32_AES_A_write_xfrsize(SI32_AES_0, 0);
   SI32_AES_A_enable_error_interrupt(SI32_AES_0);
   SI32_AES_A_enter_cipher_block_chaining_mode(SI32_AES_0);
   SI32_AES_A_exit_counter_mode(SI32_AES_0);
   SI32_AES_A_exit_bypass_hardware_mode(SI32_AES_0);
   SI32_AES_A_select_software_mode (SI32_AES_0);

   // ENABLE INTERRUPTS
   NVIC_ClearPendingIRQ(AES0_IRQn);
   NVIC_EnableIRQ(AES0_IRQn);
}

//------------------------------------------------------------------------------
void gAES0_enter_ctr_config(void)
{
   // ENABLE CLOCK
   SI32_CLKCTRL_A_enable_apb_to_modules_0(SI32_CLKCTRL_0,
                                          SI32_CLKCTRL_A_APBCLKG0_AES0CEN_ENABLED_U32);

   // ENABLE MODULE
   SI32_AES_A_enable_module(SI32_AES_0);			 

   // SETUP MODULE
   SI32_AES_A_write_xfrsize(SI32_AES_0, 0);
   SI32_AES_A_enable_error_interrupt(SI32_AES_0);
   SI32_AES_A_select_xor_path_output(SI32_AES_0); 
   SI32_AES_A_exit_cipher_block_chaining_mode(SI32_AES_0);
   SI32_AES_A_enter_counter_mode(SI32_AES_0);
   SI32_AES_A_exit_bypass_hardware_mode(SI32_AES_0);
   SI32_AES_A_disable_key_capture (SI32_AES_0);
   SI32_AES_A_select_software_mode (SI32_AES_0);

   // ENABLE INTERRUPTS
   NVIC_ClearPendingIRQ(AES0_IRQn);
   NVIC_EnableIRQ(AES0_IRQn);
}

//------------------------------------------------------------------------------
void gAES0_enter_dma_ecb_config(void)
{
   // ENABLE CLOCK
   SI32_CLKCTRL_A_enable_apb_to_modules_0(SI32_CLKCTRL_0,
                                          SI32_CLKCTRL_A_APBCLKG0_AES0CEN_ENABLED_U32);

   // ENABLE MODULE
   SI32_AES_A_enable_module(SI32_AES_0);

   // SETUP MODULE
   SI32_AES_A_write_xfrsize(SI32_AES_0, 0);
   SI32_AES_A_enable_error_interrupt(SI32_AES_0);
   SI32_AES_A_exit_cipher_block_chaining_mode(SI32_AES_0);
   SI32_AES_A_exit_counter_mode(SI32_AES_0);
   SI32_AES_A_select_xor_path_none(SI32_AES_0);
   SI32_AES_A_exit_bypass_hardware_mode(SI32_AES_0);
   SI32_AES_A_enable_key_capture (SI32_AES_0);
   SI32_AES_A_select_dma_mode (SI32_AES_0);

   // ENABLE INTERRUPTS
   NVIC_ClearPendingIRQ(AES0_IRQn);
   NVIC_EnableIRQ(AES0_IRQn);

   // SETUP DMA
   SI32_CLKCTRL_A_enable_apb_to_modules_1(SI32_CLKCTRL_0, SI32_CLKCTRL_A_APBCLKG0_I2C0);
   SI32_CLKCTRL_A_enable_ahb_to_dma_controller(SI32_CLKCTRL_0);
}

//------------------------------------------------------------------------------
void gAES0_enter_dma_cbc_config(void)
{
   // ENABLE CLOCK
   SI32_CLKCTRL_A_enable_apb_to_modules_0(SI32_CLKCTRL_0,
                                          SI32_CLKCTRL_A_APBCLKG0_AES0CEN_ENABLED_U32);

   // ENABLE MODULE
   SI32_AES_A_enable_module(SI32_AES_0);

   // SETUP MODULE
   SI32_AES_A_enable_error_interrupt(SI32_AES_0);
   SI32_AES_A_enter_cipher_block_chaining_mode(SI32_AES_0);
   SI32_AES_A_exit_counter_mode(SI32_AES_0);
   SI32_AES_A_exit_bypass_hardware_mode(SI32_AES_0);
   SI32_AES_A_select_dma_mode (SI32_AES_0);

   // ENABLE INTERRUPTS
   NVIC_ClearPendingIRQ(AES0_IRQn);
   NVIC_EnableIRQ(AES0_IRQn);

   // SETUP DMA
   SI32_CLKCTRL_A_enable_apb_to_modules_1(SI32_CLKCTRL_0, SI32_CLKCTRL_A_APBCLKG0_I2C0);
   SI32_CLKCTRL_A_enable_ahb_to_dma_controller(SI32_CLKCTRL_0);
}

//------------------------------------------------------------------------------
void gAES0_enter_dma_ctr_config(void)
{
   // ENABLE CLOCK
   SI32_CLKCTRL_A_enable_apb_to_modules_0(SI32_CLKCTRL_0,
                                          SI32_CLKCTRL_A_APBCLKG0_AES0CEN_ENABLED_U32);

   // ENABLE MODULE
   SI32_AES_A_enable_module(SI32_AES_0);

   // SETUP MODULE
   SI32_AES_A_enable_error_interrupt(SI32_AES_0);
   SI32_AES_A_exit_cipher_block_chaining_mode(SI32_AES_0);
   SI32_AES_A_enter_counter_mode(SI32_AES_0);
   SI32_AES_A_exit_bypass_hardware_mode(SI32_AES_0);
   SI32_AES_A_select_xor_path_output(SI32_AES_0);
   SI32_AES_A_disable_key_capture(SI32_AES_0);
   // All CTR encrypt and decrypt is an AES encrypt operation
   SI32_AES_A_select_encryption_mode(SI32_AES_0);
   SI32_AES_A_select_dma_mode (SI32_AES_0);

   // ENABLE INTERRUPTS
   NVIC_ClearPendingIRQ(AES0_IRQn);
   NVIC_EnableIRQ(AES0_IRQn);

   // SETUP DMA
   SI32_CLKCTRL_A_enable_apb_to_modules_1(SI32_CLKCTRL_0, SI32_CLKCTRL_A_APBCLKG0_I2C0);
   SI32_CLKCTRL_A_enable_ahb_to_dma_controller(SI32_CLKCTRL_0);
}

//-eof--------------------------------------------------------------------------
